# 几何语言

绘图和几何时无法避免地紧密相连的。为了完成复杂的绘图操作，你必须使用iOS可以表述的几何语言。本章将会带你从基础开始。首先是点-像素二分法，然后是核心结构，再然后转向UIKit对象。你将会学习这些项目都是什么，并了解他们如何在绘图中使用。

### 点和像素
在iOS中，点表示屏幕或绘图的位置。它由测量单元组成，描述了位置和绘图操作的范围。点对于物理世界测量和特殊屏幕硬件来说是不灵活的。它允许你表示独立使用中的设备上的位置信息。
点不是像素。像素是可寻址的屏幕组件，且直接和特定的硬件绑定。每个像素都独立设置了亮度和颜色值。而点则相反，对应逻辑坐标空间。
比方说，所有iPhone家族的成员都在纵向320点宽的位置展示一个对象。这些点在旧机型上为320像素宽，而在新的Retina设备上为640像素宽。而坐标系是统一的，无论你使用是Retina设备或是旧设备。
如图2-1所示，位于（160.0，240.0）的坐标，在3.5英寸的iPhone或iPod屏幕上位于中心位置，不论像素密度如何。同样的点在4英寸的iPhone或iPod上却里中心点偏上。新设备的中心变成了（160，284.0）。
在横向时，同样的点在iPhone屏幕上位于左下角。在更大的iPad屏幕上却出现在左上角。

<img src="./2-1.png" alt="图2.1" title="图2.1" width="700"/>

#### 比例

UIScreen类提供了一个scale属性。该属性反应了展示对象的像素密度和点系统之间的关系。屏幕比例属性用于转换用点测量的逻辑坐标空间和物理像素坐标系。Retina设备比例为2.0，非Retina设备为1.0。你可以通过如下方法检测设备是否为Retina设备：
```
- (BOOL)hasRetinaDisplay
{
        return ([UIScreen mainScreen].scale == 2.0f);
}

```
主屏总是关联设备当前的展现。其他的屏幕可能有通过AirPlay或苹果链接线展示的屏幕。每个屏幕都有一个availableModes属性。它提供了一个数组的解决方案对象，按由低到高的顺序排列。
很多屏幕支持多种模式。比方说，VGA可能会提供6个或以上的解决方案。解决方案的数量往往是由硬件决定的。总是会至少有一种解决方案存在。但是你总是需要提供更多选择给用户。
UIScreen也提供了两个很有用的展示尺寸的属性。bounds属性返回屏幕的边界矩形，通过点来测量。它给你提供了整个屏幕尺寸，不包括任何屏幕元素，比如状态条，导航条和切换条。applicationFrame属性也是用点来测量的。他包含了状态条如果状态条可见的话，提供了程序元素的窗口尺寸。

#### iOS 设备
表2-1总结了iOS的设备家族，并列出了每个成员的可寻址坐标空间。这里有5个比较有代表性的成员，你只会碰见3种逻辑空间（苹果也许会在未来介绍新的几何），如下几个：

* 3.5英寸iPhone设备（320.0x380.0点）
* 4.0英寸iPhone设备（320.0x568.0点）
* iPads （768.0x1024.0点）

<img src="./table2-1-1.png" alt="表2-1-1" title="表2-1-1" width="700"/>
<img src="./table2-1-2.png" alt="表2-1-2" title="表2-1-2" width="700"/>

### 视图坐标
有很多绘图代码都紧密关联着你所需绘制的视图，特别是使用drawRect：方法的时候。所有视图的原生坐标系都是左上为原点的。
在iOS7以后，可以自己通过edgesForExtenedLayout属性调整视图控制器的原点是否在跳行条上或者导航条下。默认情况，是从导航条以下开始算原点的，提供一个边对边的UI。

####  Frames 和 Bounds
视图（至少）会存在于两个世界。一个视图frame属性是根据他的父视图的坐标系来确定的。该属性确定了视图在其父视图上的位置和大小。而一个视图的bounds属性在他自己的坐标系中定义，所以他的定位默认为（0，0）。（当你只使用视图的一部分时，这个定位值也是会变的，就比如说使用scroll view）。视图的frame和bounds属性时紧密相连的一对。一个改变了另一个也随之改变的。
思考图2-2，灰色视图的起始点为（80，100）。水平方向200点，垂直方向150点。他在父视图中的frame属性为{80，100，200， 150}。在自己的坐标系中，bounds属性为{0，0，200，150}。延展的值保持一致，而起始点的值不同。

|             |  Gray View          |  Parent  |
|  :-------------: |:-------------:| ----- |
|   Origin     |    {0, 0} | {80, 100} |
|  Circle    |  {66, 86}      |  {146, 186} |


  <img src="./2-2.png" alt="表2-2" title="表2-2" width="700"/>

一个点的位置坐标是依据坐标系视情况而定的。在图2-2中，在灰色视图中一个圆包裹了一个点。在灰色视图的坐标系中，点位置为（66，86）。在他的父视图的坐标系中，点的位置坐标为（146， 186）。直接通过坐标相加进行转换，（66 + 80， 100 + 86），即（146，186）。

> 注意： 一个视图的frame是通过bounds，center和其他transform计算来的。他描述了可以包括整个视图的最小矩形。

#### 坐标系转换
iOS SDK提供了很多坐标系转换的方法。比如说，你也许会希望吧一个点从视图坐标系转换到它的父视图的坐标系中，来确定在它的父视图的哪个位置进行绘制。你可以如下这么做：
```
CGPoint convertedPoint = [outerView convertPoint:samplePoint fromView:grayView];
```
你可以使用任何视图实例调用这个方法。尤其是你想要转换一个点到另一个坐标系上时（toView：）或事从另一个坐标系转移过来（fromView：），像例子中那样。
这些视图必须存在于同一个UIWindow，否则这个方法不会奏效。这些视图不需要有任何其他的相关关系了。然而，他们可以是兄弟姐妹，父子，祖先，或其他关系。这个方法会返回一个你想要得到的点坐标。
转换矩形的方法和转换点的方法也是类似的。把一个矩形从一个视图转换到另一个坐标系，使用convertRect：fromView：。转换回来，使用convertRect：toView：

### 关键结构体
iOS绘图使用四个关键的结构体来定义几何基元：点，尺寸，矩形，转换。这些结构体都使用同一额单位：逻辑点。点通过CGFloat值来定义。在iOS中用float，而OS X使用double。
不像像素，固定整数点且与设备硬件无关。他们的值和亚像素精度提供的数学坐标有关。iOS绘图系统使用你习惯的数学。

你会用到的四个基元如下：
* CGPoint —— 点结构由x和y组成，他们定义了逻辑位置。
* CGSize —— 尺寸结构由width和height组成，他们定义了横纵轴上的延展
* CGRect —— 矩形由使用点定义的origin属性和一个size属性组成。
* CGAffineTransform —— 放射变换结构描述了几何项的改变——特别是，一个项目如何放置，放缩，旋转，他储存了a，b，c，d，tx和ty六个值的矩阵来定义变换。

下一章会更加深入地介绍这几项。你需要先有一个基础的几何上的认识之后，才可以更加深入地在绘图中使用他们。

#### 点
CGPoint储存了逻辑位置，通过定义x和y的值来确定。CGPointMake（）可以很方便地通过两个参数来创建结构体：
```
struct CGPoint{
    CGFloat x;
    CGFloat y;
}
```
这些值可以是任何浮点数的点值。负数依然有效。

#### 尺寸
CGSize结构体储存了两个方向上的延展，本别是width和height。使用CGSizeMake（）方法创建，两值也可以为负数，然而日常中很少这么用：
```
struct CGSize{
CGFloat width;
CGFloat height;
}
```

#### 矩形
CGRect结构体由两个子结构体组成：CGPoint定义了矩形的位置，CGSize定义了延展的大小。CGRectMake（）方法用四个参数定了rect结构体。四个参数的顺序为x，y, width, height。比方说，CGRectMake（0，0， 50，100）：

```
struct CGRect{
    CGPoint origin;
    CGSize size;
}
```
调用CGRectStandardize()把size中为负的部分转换为相等的正值。

#### 转换
转换是iOS几何学中最强大一个部分。他允许点从一个坐标系转移到另一个坐标系。也允许你放缩旋转，镜像，位移等等当你绘制的时候，通过保存线性和相关比例。你在第一章中调整绘图上下文位置时已经遇到了绘制中进行转换，或当你读到第五章操作路径或形装时，也会遇到。
在2D和3D图像中，转换都是很广泛的被应用到的。转换提供了复杂的架构来解决几何问题。核心图像的版本（CGAffineTransform）使用3x3的矩阵，来解决2D问题。而在3D中，使用Core Animation中的图层定义的4x4的矩阵。Quartz转换允许你进行几何的位移放缩旋转。
所有的转换都可以用如下所示的底层转换矩阵表示：

  <img src="./other1.png" alt="1" title="1" width="700"/>
  
  用C语言机构提表示为：
  ```
  struct CGAffineTransform{
         CGFloat a;
         CGFloat b;
         CGFloat c;
         CGFloat d;
         CGFloat tx;
         CGFloat ty;
  }
```

##### 创建转换
